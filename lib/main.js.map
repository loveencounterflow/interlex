{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/main.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n'use strict'\n\n#===========================================================================================================\n{ hide\n  debug\n  info\n  rpr                   } = require './helpers'\n#-----------------------------------------------------------------------------------------------------------\n\n\n#===========================================================================================================\ninternals = new class Internals\n  constructor: ->\n    SLR             = require 'regex'\n    #.........................................................................................................\n    ### thx to https://github.com/sindresorhus/identifier-regex ###\n    jsid_re         = SLR.regex\"\"\" ^ [ $ _ \\p{ID_Start} ] [ $ _ \\u200C \\u200D \\p{ID_Continue} ]* $ \"\"\"\n    jump_spec_back  = '..'\n    jump_spec_re    = SLR.regex\" (?<back> ^ #{jump_spec_back} $ ) | (?<fore> #{jsid_re} )\"\n    #.........................................................................................................\n    @slevithan_regex      = SLR\n    @jsid_re              = jsid_re\n    @jump_spec_back       = jump_spec_back\n    @jump_spec_re         = jump_spec_re\n    #.......................................................................................................\n    # thx to https://github.com/loveencounterflow/coffeescript/commit/27e0e4cfee65ec7e1404240ccec6389b85ae9e69\n    @regex_flags_re             = /^(?!.*(.).*\\1)[dgimsuvy]*$/\n    @forbidden_slr_flags_re     = /[uv]/g\n    @forbidden_plain_flags_re   = /[u]/g\n    @mandatory_slr_flags_txt    = 'dy'\n    @mandatory_plain_flags_txt  = 'dvy'\n\n    #-------------------------------------------------------------------------------------------------------\n    @validate_regex_flags = ( flags ) =>\n      unless ( typeof flags ) is 'string'\n        throw new Error \"Ωilx___1 expected a text, got #{rpr flags}\"\n      unless @regex_flags_re.test flags\n        throw new Error \"Ωilx___2 illegal or duplicate flags in #{rpr flags}\"\n      return flags\n\n    #-------------------------------------------------------------------------------------------------------\n    @normalize_regex_flags = ({ flags, mode, }) =>\n      ### Given a RegExp `flags` text, sets `d`, `y`, removes `u`, `v`, and returns sorted text with unique\n      flags. ###\n      switch mode\n        when 'slr'\n          forbidden_flags_re  = @forbidden_slr_flags_re\n          mandatory_flags_txt = @mandatory_slr_flags_txt\n        when 'plain'\n          forbidden_flags_re  = @forbidden_plain_flags_re\n          mandatory_flags_txt = @mandatory_plain_flags_txt\n        else throw new Error \"Ωilx___3 internal error: unknown mode: #{rpr mode}\"\n      flags   = @validate_regex_flags flags ? ''\n      flags   = flags.replace forbidden_flags_re, ''\n      flags  += mandatory_flags_txt\n      return @get_unique_sorted_letters flags\n\n    #-------------------------------------------------------------------------------------------------------\n    @get_unique_sorted_letters = ( text ) => [ ( new Set text )..., ].sort().join ''\n\n    #-------------------------------------------------------------------------------------------------------\n    @normalize_regex = ( regex ) =>\n      ### Given a `regex`, return a new regex with the same pattern but normalized flags. ###\n      ### TAINT use proper typing ###\n      unless regex instanceof RegExp\n        throw new Error \"Ωilx___4 expected a regex, got #{rpr regex}\"\n      return new RegExp regex.source, ( @normalize_regex_flags { flags: regex.flags, mode: 'plain', } )\n\n    #-------------------------------------------------------------------------------------------------------\n    @sort_lexemes_by_length_dec = ( lexemes ) -> lexemes.sort ( a, b ) ->\n      return -1 if a.length > b.length\n      return +1 if a.length < b.length\n      return  0\n\n    #-------------------------------------------------------------------------------------------------------\n    return undefined\n\n#-----------------------------------------------------------------------------------------------------------\nnew_regex_tag = ( global_flags = null ) ->\n  { regex }     = internals.slevithan_regex\n  global_flags  = internals.normalize_regex_flags { flags: global_flags, mode: 'slr', }\n  #.........................................................................................................\n  tag_function  = ( P... ) -> ( regex global_flags ) P...\n  #.........................................................................................................\n  return new Proxy tag_function,\n    get: ( target, key ) ->\n      return undefined unless typeof key is 'string'\n      flags = global_flags + key\n      flags = internals.get_unique_sorted_letters   flags\n      flags = internals.normalize_regex_flags     { flags, mode: 'slr', }\n      return regex flags\n\n#-----------------------------------------------------------------------------------------------------------\nrx = new_regex_tag()\n\n\n#===========================================================================================================\nclass Token\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    @name       = cfg.name\n    cfg.matcher = internals.normalize_regex cfg.matcher\n    hide @, 'level',        cfg.level\n    hide @, 'grammar',      cfg.level.grammar\n    hide @, 'matcher',      cfg.matcher\n    hide @, 'jump',         @constructor._parse_jump cfg.jump ? null\n    hide @, 'jump_spec',    cfg.jump                          ? null\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  match_at: ( start, source ) ->\n    @matcher.lastIndex = start\n    return null unless ( match = source.match @matcher )?\n    return new Lexeme @, match\n\n  #---------------------------------------------------------------------------------------------------------\n  @_parse_jump: ( jump_spec ) ->\n    return null unless jump_spec?\n    ### TAINT use cleartype ###\n    unless ( match = jump_spec.match internals.jump_spec_re )?\n      throw new Error \"Ωilx___5 expected a well-formed jump literal, got #{rpr jump_spec}\"\n    return { action: 'back', target: null,              } if match.groups.back\n    return { action: 'fore', target: match.groups.fore, }\n\n\n#===========================================================================================================\nclass Lexeme\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( token, match ) ->\n    @name       = token.name\n    @fqname     = \"#{token.level.name}.#{token.name}\"\n    @level      = token.level\n    @hit        = match[ 0 ]\n    @start      = match.index\n    @stop       = @start + @hit.length\n    @length     = @hit.length\n    @groups     = match.groups ? null\n    @jump       = token.jump\n    @jump_spec  = token.jump_spec\n    name        = token.grammar.cfg.counter_name\n    count       = token.grammar.state.count\n    @[ name ]   = count\n    return undefined\n\n\n#===========================================================================================================\nclass Level\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    cfg    ?= {}\n    @name   = cfg.name ? 'gnd'\n    hide @, 'grammar',  cfg.grammar\n    hide @, 'tokens',   [ ( cfg.tokens ? [] )..., ]\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  [Symbol.iterator]: -> yield t for t in @tokens\n\n  #---------------------------------------------------------------------------------------------------------\n  new_token: ( cfg ) ->\n    if cfg.level? and cfg.level isnt @\n      throw new Error \"Ωilx___6 inconsistent level\"\n    @tokens.push token = new Token { cfg..., level: @, }\n    return token\n\n  #---------------------------------------------------------------------------------------------------------\n  match_all_at: ( start, source ) ->\n    R = []\n    for token from @\n      continue unless ( lexeme = token.match_at start, source )?\n      R.push lexeme\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  match_first_at: ( start, source ) ->\n    for token from @\n      return lexeme if ( lexeme = token.match_at start, source )?\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  match_longest_at: ( start, source ) ->\n    return null         if ( lexemes = @match_all_at start, source ).length is 0\n    return lexemes[ 0 ] if lexemes.length is 1\n    ### NOTE: Because JS guarantees stable sorts, we know that in case there were several lexemes with the\n    same maximum length, the ones that come earlier in the unsorted list (which corresponds to the order in\n    that the tokens got declared) will also come earlier after sorting; hence, the first lexeme in the list\n    after sorting will be one that has both maximum length (because of the sort) *and* come earlier in the\n    list of declarations (because of sort stability): ###\n    return ( internals.sort_lexemes_by_length_dec lexemes )[ 0 ]\n\n\n#===========================================================================================================\nclass Stack\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( P... ) ->\n    @data = Array.from P...\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  is_empty: -> @data.length is 0\n\n  #---------------------------------------------------------------------------------------------------------\n  peek: ->\n    if @is_empty()\n      throw new Error \"stack is empty\"\n    return @data.at -1\n\n  #---------------------------------------------------------------------------------------------------------\n  pop: ->\n    if @is_empty()\n      throw new Error \"stack is empty\"\n    return @data.pop()\n\n  #---------------------------------------------------------------------------------------------------------\n  push: ( P... ) -> @data.push P...\n\n\n#===========================================================================================================\nclass Grammar\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    cfg_template          =\n      name:                 'g'\n      counter_name:         'line_nr'\n      counter_value:        1\n      counter_step:         1\n    @cfg                 ?= { cfg_template..., cfg..., }\n    @name                 = @cfg.name\n    @state                = { count: null, }\n    @reset_count()\n    @start_level_name     = null\n    hide @, 'start_level',  null\n    hide @, 'levels',       {}\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  reset_count: ->\n    @state.count = @cfg.counter_value\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  new_level: ( cfg ) ->\n    if @levels[ cfg.name ]?\n      throw new Error \"Ωilx___8 level #{rpr level.name} elready exists\"\n    level                   = new Level { cfg..., grammar: @, }\n    @levels[ level.name ]   = level\n    unless @start_level?\n      hide @, 'start_level', level\n      @start_level_name = level.name\n    return level\n\n  #---------------------------------------------------------------------------------------------------------\n  get_lexemes: ( P... ) -> [ ( @walk_lexemes P... )..., ]\n\n  #---------------------------------------------------------------------------------------------------------\n  walk_lexemes: ( source ) ->\n    { f } = require '../../effstring'\n    start = 0\n    stack = new Stack [ @start_level, ]\n    #.......................................................................................................\n    loop\n      lexeme  = null\n      level   = stack.peek()\n      lexeme  = level.match_first_at start, source\n      #.....................................................................................................\n      ### Terminate if none of the tokens of the current level has matched at the current position: ###\n      break unless lexeme?\n      #.....................................................................................................\n      ### Refuse to accept empty match: ###\n      if lexeme.hit is ''\n        { fqname\n          start } = lexeme\n        snippet   = source[ start - 10 ... start ] + '⚠' + source[ start + 1 .. start + 10 ]\n        throw new Error \"Ωilx___9 encountered zero-length match for token #{rpr fqname} at position #{lexeme.start} (indicated by '⚠': #{rpr snippet})\"\n      #.....................................................................................................\n      yield lexeme\n      @state.count += @cfg.counter_step\n      start         = lexeme.stop\n      #.....................................................................................................\n      continue unless ( jump = lexeme.jump )?\n      switch jump.action\n        #...................................................................................................\n        when 'fore'\n          ### TAINT encapsulate ###\n          unless ( new_level = @levels[ jump.target ] )?\n            throw new Error \"unknown level #{rpr jump.target}\"\n          stack.push new_level\n          continue\n        #...................................................................................................\n        when 'back'\n          stack.pop()\n          continue\n      #.....................................................................................................\n      throw new Error \"unknown jump action #{rpr lexeme.jump.action}\"\n    return null\n\n\n  #===========================================================================================================\n  ###\n  `Token` defines `matcher`, can jump into a level or back\n  `Level` has one or more `Token`s\n  `Grammar` has one or more `Level`s\n  `Lexeme` produced by a `Token` instance when matcher matches source\n\n  ###\n\n\nmodule.exports = {\n  Token\n  Lexeme\n  Level\n  Grammar\n  internals\n  rx\n  new_regex_tag }\n\n"
  ]
}