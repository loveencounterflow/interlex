{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/main.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n'use strict'\n\n#===========================================================================================================\n{ Levelstack\n  hide\n  hide_getter\n  set_getter\n  clone\n  # insert_position_marker\n  quote_source\n  # create_pod_from_template\n  debug\n  info\n  rpr                   } = require './helpers'\n{ type_of\n  std\n  isa\n  isa_optional\n  create\n  validate\n  validate_optional\n  Typespace             } = require 'cleartype'\n{ nfa                   } = require 'normalize-function-arguments'\n\n\n#===========================================================================================================\n{ ilx, std2, } = do =>\n\n  #---------------------------------------------------------------------------------------------------------\n  ilx =\n    cfg_cast:\n      $isa:       ( x ) -> ( not x? ) or ( @ct.isa std.function, x ) or ( @ct.isa std2.generatorfunction, x )\n      $describe:  ( x ) ->\n        ### TAINT rewrite using @ct.isa &c ###\n        return { cast: null,  cast_method: null,    } unless x?\n        return { cast: x,     cast_method: 'call',  } if ( isa std.function,           x )\n        return { cast: x,     cast_method: 'walk',  } if ( isa std2.generatorfunction, x )\n        ### TAINT code duplication ###\n        ### TAINT effort duplication ###\n        validate ilx.cfg_cast, x\n\n  #---------------------------------------------------------------------------------------------------------\n  std2 =\n    generatorfunction:\n      $isa:         ( x ) -> ( Object::toString.call x ) is '[object GeneratorFunction]'\n      $create:      -> ( -> yield return null )\n    generator:\n      $isa:         ( x ) -> ( Object::toString.call x ) is '[object Generator]'\n      $create:      -> ( -> yield return null )()\n\n  #---------------------------------------------------------------------------------------------------------\n  return { ilx, std2, }\n\n\n\n# 8888888  888b    888  88888888888  8888888888  8888888b.   888b    888         d8888  888        .d8888b.\n#   888    8888b   888      888      888         888   Y88b  8888b   888        d88888  888       d88P  Y88b\n#   888    88888b  888      888      888         888    888  88888b  888       d88P888  888       Y88b.\n#   888    888Y88b 888      888      8888888     888   d88P  888Y88b 888      d88P 888  888        \"Y888b.\n#   888    888 Y88b888      888      888         8888888P\"   888 Y88b888     d88P  888  888           \"Y88b.\n#   888    888  Y88888      888      888         888 T88b    888  Y88888    d88P   888  888             \"888\n#   888    888   Y8888      888      888         888  T88b   888   Y8888   d8888888888  888       Y88b  d88P\n# 8888888  888    Y888      888      8888888888  888   T88b  888    Y888  d88P     888  88888888   \"Y8888P\"\n#\n#\n#===========================================================================================================\ninternals = new class Internals\n  constructor: ->\n    SLR             = require 'regex'\n    #.........................................................................................................\n    @Levelstack           = Levelstack\n    @clone                = clone\n    @slevithan_regex      = SLR\n    ### thx to https://github.com/sindresorhus/identifier-regex ###\n    @jsid_re              = SLR.regex\"\"\" [ $ _ \\p{ID_Start} ] [ $ _ \\u200C \\u200D \\p{ID_Continue} ]* \"\"\"\n    @jump_spec_back       = '..'\n    @jump_spec_res        = [\n      { carry: false,  action: 'back', fit: SLR.regex\"^ (?<target> #{ @jump_spec_back  } )   $\", }\n      { carry: false,  action: 'fore', fit: SLR.regex\"^ (?<target> #{ @jsid_re         } )   $\", }\n      { carry: true,   action: 'back', fit: SLR.regex\"^ (?<target> #{ @jump_spec_back  } ) ! $\", }\n      { carry: true,   action: 'fore', fit: SLR.regex\"^ (?<target> #{ @jsid_re         } ) ! $\", }\n      ]\n    @fqname_re            = SLR.regex\"^ (?<level_name> #{ @jsid_re } ) \\. (?<token_name> #{ @jsid_re } ) $\"\n    #.......................................................................................................\n    # thx to https://github.com/loveencounterflow/coffeescript/commit/27e0e4cfee65ec7e1404240ccec6389b85ae9e69\n    @regex_flags_re             = /^(?!.*(.).*\\1)[dgimsuvy]*$/\n    @forbidden_slr_flags_re     = /[uv]/g\n    @forbidden_plain_flags_re   = /[u]/g\n    @mandatory_slr_flags_txt    = 'dy'\n    @mandatory_plain_flags_txt  = 'dvy'\n\n    #-------------------------------------------------------------------------------------------------------\n    @validate_regex_flags = ( flags ) =>\n      unless ( typeof flags ) is 'string'\n        throw new Error \"Ωilx___1 expected a text, got #{rpr flags}\"\n      unless @regex_flags_re.test flags\n        throw new Error \"Ωilx___2 illegal or duplicate flags in #{rpr flags}\"\n      return flags\n\n    #-------------------------------------------------------------------------------------------------------\n    @normalize_regex_flags = ({ flags, mode, }) =>\n      ### Given a RegExp `flags` text, sets `d`, `y`, removes `u`, `v`, and returns sorted text with unique\n      flags. ###\n      switch mode\n        when 'slr'\n          forbidden_flags_re  = @forbidden_slr_flags_re\n          mandatory_flags_txt = @mandatory_slr_flags_txt\n        when 'plain'\n          forbidden_flags_re  = @forbidden_plain_flags_re\n          mandatory_flags_txt = @mandatory_plain_flags_txt\n        else throw new Error \"Ωilx___3 internal error: unknown mode: #{rpr mode}\"\n      flags   = @validate_regex_flags flags ? ''\n      flags   = flags.replace forbidden_flags_re, ''\n      flags  += mandatory_flags_txt\n      return @get_unique_sorted_letters flags\n\n    #-------------------------------------------------------------------------------------------------------\n    @get_unique_sorted_letters = ( text ) => [ ( new Set text )..., ].sort().join ''\n\n    #-------------------------------------------------------------------------------------------------------\n    @as_regex = ( text_or_regex ) =>\n      switch type = type_of text_or_regex\n        when 'regex'  then return text_or_regex\n        when 'text'   then return SLR.regex\"#{text_or_regex}\"\n        else throw new Error \"Ωilx___4 expected a text or a regex, got a #{type}\"\n\n    #-------------------------------------------------------------------------------------------------------\n    @normalize_regex = ( regex ) =>\n      ### Given a `regex`, return a new regex with the same pattern but normalized flags. ###\n      ### TAINT use proper typing ###\n      unless regex instanceof RegExp\n        throw new Error \"Ωilx___5 expected a regex, got #{rpr regex}\"\n      return new RegExp regex.source, ( @normalize_regex_flags { flags: regex.flags, mode: 'plain', } )\n\n    #-------------------------------------------------------------------------------------------------------\n    @sort_lexemes_by_length_dec = ( lexemes ) -> lexemes.sort ( a, b ) ->\n      return -1 if a.length > b.length\n      return +1 if a.length < b.length\n      return  0\n\n    #-------------------------------------------------------------------------------------------------------\n    return undefined\n\n#-----------------------------------------------------------------------------------------------------------\nnew_regex_tag = ( global_flags = null ) ->\n  { regex }     = internals.slevithan_regex\n  global_flags  = internals.normalize_regex_flags { flags: global_flags, mode: 'slr', }\n  #.........................................................................................................\n  tag_function  = ( P... ) -> ( regex global_flags ) P...\n  #.........................................................................................................\n  return new Proxy tag_function,\n    get: ( target, key ) ->\n      return undefined unless typeof key is 'string'\n      flags = global_flags + key\n      flags = internals.get_unique_sorted_letters   flags\n      flags = internals.normalize_regex_flags     { flags, mode: 'slr', }\n      return regex flags\n\n#-----------------------------------------------------------------------------------------------------------\nrx = new_regex_tag()\n\n\n\n#                                             88888888888   .d88888b.   888    d8P   8888888888  888b    888\n#                                                 888      d88P\" \"Y88b  888   d8P    888         8888b   888\n#                                                 888      888     888  888  d8P     888         88888b  888\n#                                                 888      888     888  888d88K      8888888     888Y88b 888\n#                                                 888      888     888  8888888b     888         888 Y88b888\n#                                                 888      888     888  888  Y88b    888         888  Y88888\n#                                                 888      Y88b. .d88P  888   Y88b   888         888   Y8888\n#                                                 888       \"Y88888P\"   888    Y88b  8888888888  888    Y888\n#\n#\n#===========================================================================================================\nclass Token\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    cfg_template =\n      name:         null\n      level:        null\n      grammar:      null\n      fit:          null\n      jump:         null\n      merge:        false\n      emit:         true\n      cast:         null\n    #.......................................................................................................\n    cfg         = { cfg_template..., cfg..., }\n    @name       = cfg.name\n    cfg.fit     = internals.normalize_regex internals.as_regex cfg.fit\n    hide @, 'level',                cfg.level\n    hide @, 'grammar',              cfg.level.grammar\n    hide @, 'fit',                  cfg.fit\n    hide @, 'jump',                 ( @constructor._parse_jump cfg.jump, @level ) ? null\n    hide @, 'merge',                cfg.merge\n    hide @, 'emit',                 cfg.emit\n    set_getter @, 'fqname',     => \"#{@level.name}.#{@name}\"\n    { cast, cast_method, } = ilx.cfg_cast.$describe cfg.cast\n    hide @, 'cast',                 cast\n    hide @, 'cast_method',          cast_method\n    ### TAINT use proper typing ###\n    hide @, 'data_merge_strategy', switch true\n      when @merge is false                        then null\n      when @merge is true                         then 'list'\n      when @merge is 'assign'                     then 'assign'\n      when @merge is 'list'                       then 'list'\n      when ( isa std.function, @merge )           then 'call'\n      else throw new Error \"Ωilx___6 expected a valid value for `merge`, got #{rpr @merge}\"\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  match_at: ( start, source ) -> @_match_at start, source\n\n  #---------------------------------------------------------------------------------------------------------\n  _match_at: ( start, source, fit = null ) ->\n    @fit.lastIndex = start\n    return null unless ( match = source.match fit ? @fit )?\n    return new Lexeme @, match\n\n  #---------------------------------------------------------------------------------------------------------\n  match_any_at: ( start, source ) ->\n    ### Same as `@match_at()` but doesn't test for match, so matches always ###\n    @fit.lastIndex = start\n    return null unless ( match = source.match /|/ )?\n    return new Lexeme @, match\n\n  #---------------------------------------------------------------------------------------------------------\n  @_parse_jump: ( spec, level = null ) ->\n    return null unless spec?\n    match = null\n    for { carry, action, fit, } in internals.jump_spec_res\n      break if ( match = spec.match fit )?\n    unless match?\n      throw new Error \"Ωilx___7 encountered illegal jump spec #{rpr spec}\"\n    { target, } = match.groups\n    if level? and ( target is level.name )\n      throw new Error \"Ωilx___8 cannot jump to same level, got #{rpr target}\"\n    return { spec, carry, action, target, }\n\n\n\n#                                   888       8888888888  Y88b   d88P  8888888888  888b     d888  8888888888\n#                                   888       888          Y88b d88P   888         8888b   d8888  888\n#                                   888       888           Y88o88P    888         88888b.d88888  888\n#                                   888       8888888        Y888P     8888888     888Y88888P888  8888888\n#                                   888       888            d888b     888         888 Y888P 888  888\n#                                   888       888           d88888b    888         888  Y8P  888  888\n#                                   888       888          d88P Y88b   888         888   \"   888  888\n#                                   88888888  8888888888  d88P   Y88b  8888888888  888       888  8888888888\n#\n#\n#===========================================================================================================\nclass Lexeme\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( token, match ) ->\n    @name                 = token.name\n    @hit                  = match[ 0 ]\n    @start                = match.index\n    @stop                 = @start + @hit.length\n    @jump                 = token.jump\n    @token                = token\n    @lnr                  = token.grammar.state.lnr\n    # @terminate            = token.termin\n    @data                 = Object.create null\n    set_getter @, 'fqname',     => \"#{@level.name}.#{@name}\"\n    set_getter @, 'length',     => @hit.length\n    set_getter @, 'is_error',   => /^\\$?error$/.test @token.level.name\n    set_getter @, 'is_signal',  => @token.level.name is '$signal'\n    set_getter @, 'is_system',  => @token.level.is_system\n    set_getter @, 'is_user',    => not @is_system\n    hide       @, 'source',     match.input\n    hide       @, 'new_lexeme', @new_lexeme.bind @\n    #.......................................................................................................\n    @assign match.groups\n    @set_level token.level\n    hide_getter @, 'has_data',    =>\n      return true for _ of @data\n      return false\n    #.......................................................................................................\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  _as_proxy: ( Q... ) -> new Proxy @,\n    get: ( target, key ) ->\n      return target if key is 'lexeme'\n      return Reflect.get arguments...\n\n  #---------------------------------------------------------------------------------------------------------\n  _clone: ->\n    R       = clone @\n    R.data  = clone @data\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  set_level: ( level ) ->\n    ### TAINT should typecheck ###\n    @level = level\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  assign: ( P... ) -> Object.assign @data, P...\n\n  #---------------------------------------------------------------------------------------------------------\n  new_lexeme: ( fqname, start, source, data = null ) ->\n    token   = @token.grammar.token_from_fqname fqname\n    R       = token._match_at start, source\n    R.assign data\n    return R\n\n\n#                                                     888       8888888888  888     888  8888888888  888\n#                                                     888       888         888     888  888         888\n#                                                     888       888         888     888  888         888\n#                                                     888       8888888     Y88b   d88P  8888888     888\n#                                                     888       888          Y88b d88P   888         888\n#                                                     888       888           Y88o88P    888         888\n#                                                     888       888            Y888P     888         888\n#                                                     88888888  8888888888      Y8P      8888888888  88888888\n#\n#\n#===========================================================================================================\nclass Level\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    cfg                          ?= {}\n    @name                         = cfg.name      ? 'gnd'\n    @is_system                    = cfg.is_system ? false\n    { cast, cast_method, }        = ilx.cfg_cast.$describe cfg.cast\n    #.......................................................................................................\n    hide @, 'cast',         cast\n    hide @, 'cast_method',  cast_method\n    hide @, 'grammar',      cfg.grammar\n    hide @, 'tokens',       Object.create null\n    hide @, 'positions',    new Set()\n    #.......................................................................................................\n    hide_getter @, 'strategy', => @grammar.cfg.strategy\n    # hide @,         'cast',         validate ilx.cfg_cast, cfg.cast ? null\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  [Symbol.iterator]: -> yield token for name, token of @tokens\n\n  #---------------------------------------------------------------------------------------------------------\n  _on_before_scan: ->\n    @positions.clear()\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  new_token: nfa ( name, fit, cfg ) ->\n    R = new Token { cfg..., level: @, }\n    if Reflect.has @tokens, R.name\n      throw new Error \"Ωilx___9 encountered duplicate token name #{rpr R.name}\"\n    @tokens[ R.name ] = R\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  match_all_at: ( start, source ) ->\n    R = []\n    for token from @\n      continue unless ( lexeme = token.match_at start, source )?\n      R.push lexeme\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  match_first_at: ( start, source ) ->\n    for token from @\n      return lexeme if ( lexeme = token.match_at start, source )?\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  match_longest_at: ( start, source ) ->\n    return null         if ( lexemes = @match_all_at start, source ).length is 0\n    return lexemes[ 0 ] if lexemes.length is 1\n    ### NOTE: Because JS guarantees stable sorts, we know that in case there were several lexemes with the\n    same maximum length, the ones that come earlier in the unsorted list (which corresponds to the order in\n    that the tokens got declared) will also come earlier after sorting; hence, the first lexeme in the list\n    after sorting will be one that has both maximum length (because of the sort) *and* come earlier in the\n    list of declarations (because of sort stability): ###\n    return ( internals.sort_lexemes_by_length_dec lexemes )[ 0 ]\n\n  #---------------------------------------------------------------------------------------------------------\n  match_at: ( start, source ) ->\n    ### Loop Detection: refuse to visit same position twice ###\n    if ( not @is_system ) and @positions.has start\n      ### TAINT show source ###\n      quote   = quote_source source, start\n      message = \"encountered loop at position #{rpr start} #{quote}\"\n      switch @grammar.cfg.loop_errors\n        when 'emit' then return @grammar._new_error_signal \\\n          'Ωilx__10', 'loop', start, start, source, message\n        when 'throw' then throw new Error \"Ωilx__11 #{message}\"\n        else throw new Error \"Ωilx__12 should never happen: got unknown value for loop_errors: #{rpr @grammar.cfg.loop_errors}\"\n    @positions.add start\n    #.......................................................................................................\n    switch @strategy\n      when 'first'    then  lexeme = @match_first_at    start, source\n      when 'longest'  then  lexeme = @match_longest_at  start, source\n      else throw new Error \"Ωilx__13 should never happen: got strategy: #{rpr @strategy}\"\n    #.......................................................................................................\n    ### Accept no lexeme matching but refuse lexeme with empty match: ###\n    return null   unless lexeme?\n    return lexeme unless ( lexeme.hit is '' ) and ( not lexeme.jump? )\n    { fqname\n      start } = lexeme\n    quote     = quote_source source, lexeme.start\n    throw new Error \"Ωilx__14 encountered zero-length match for token #{rpr fqname} at position #{lexeme.start} #{quote}\"\n\n\n#                .d8888b.   8888888b.          d8888  888b     d888  888b     d888         d8888  8888888b.\n#               d88P  Y88b  888   Y88b        d88888  8888b   d8888  8888b   d8888        d88888  888   Y88b\n#               888    888  888    888       d88P888  88888b.d88888  88888b.d88888       d88P888  888    888\n#               888         888   d88P      d88P 888  888Y88888P888  888Y88888P888      d88P 888  888   d88P\n#               888  88888  8888888P\"      d88P  888  888 Y888P 888  888 Y888P 888     d88P  888  8888888P\"\n#               888    888  888 T88b      d88P   888  888  Y8P  888  888  Y8P  888    d88P   888  888 T88b\n#               Y88b  d88P  888  T88b    d8888888888  888   \"   888  888   \"   888   d8888888888  888  T88b\n#                \"Y8888P88  888   T88b  d88P     888  888       888  888       888  d88P     888  888   T88b\n#\n#\n#===========================================================================================================\nclass Grammar\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    cfg_template =\n      name:             'g'\n      strategy:         'first'\n      emit_signals:     true\n      loop_errors:      'emit'\n      earlystop_errors: 'emit'\n      cast:             null\n      lnr:              1\n      data:             null\n      reset_lnr:        false\n      reset_data:       false\n      reset_errors:     false\n      reset_stack:      null\n      linking:          false\n      supply_eol:       false\n    #.......................................................................................................\n    @cfg                   ?= { cfg_template..., cfg..., }\n    #.......................................................................................................\n    if ( @cfg.linking is true ) and ( @cfg.reset_stack isnt null )\n      throw new Error \"Ωilx__15 when linking is true, reset_stack cannt be set to true\"\n    @cfg.reset_stack ?= not @cfg.linking\n    @cfg.supply_eol = '\\n' if ( @cfg.supply_eol is true )\n    #.......................................................................................................\n    @state =\n      lnr:              null\n      errors:           []\n      stack:            new Levelstack()\n      current_token:    null\n      current_stop:     0\n    #.......................................................................................................\n    @name                   = @cfg.name\n    @start_level_name       = null\n    hide @, 'system_tokens',  null\n    hide @, 'start_level',    null\n    hide @, 'levels',         Object.create null\n    hide @, 'data',           Object.create null\n    hide_getter @, 'has_errors', -> @state.errors.length > 0\n    #.......................................................................................................\n    { cast, cast_method, } = ilx.cfg_cast.$describe @cfg.cast\n    hide @, 'cast',         cast\n    hide @, 'cast_method',  cast_method\n    #.......................................................................................................\n    @_compile_cfg_data()\n    @_add_system_levels()\n    @reset()\n    return undefined\n\n  #=========================================================================================================\n  reset_lnr: ( P... ) ->\n    if P.length isnt 0\n      throw new Error \"Ωilx__16 Grammar::cfg.reset_lnr() does not accept arguments, got #{P.length} arguments\"\n    @state.lnr = @cfg.lnr\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _compile_cfg_data: ->\n    @cfg.data ?= {}\n    for key, descriptor of Object.getOwnPropertyDescriptors @cfg.data\n      continue unless isa std.function, descriptor.value\n      set_getter @cfg.data, key, descriptor.value.bind @\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  reset_data: ( P... ) ->\n    if P.length isnt 0\n      throw new Error \"Ωilx__17 Grammar::cfg.reset_data() does not accept arguments, got #{P.length} arguments\"\n    delete @data[ key ] for key of @data\n    @assign @data, @cfg.data\n    # ( @data[ key ] = fn.call @ ) for key, fn of @data when isa std.function, fn\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  reset_stack: ->\n    @state.stack.clear()\n    @state.current_token = null\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  reset: ->\n    @reset_lnr()\n    @reset_data()\n    @reset_stack()\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  reset_errors: ->\n    @state.errors = []\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  assign: ( P... ) -> Object.assign @data, P...\n\n\n  #=========================================================================================================\n  _add_system_levels: ->\n    $signal = @new_level { name: '$signal', system: true, }\n    $error  = @new_level { name: '$error',  system: true, }\n    hide @, 'system_tokens',\n      start:      $signal.new_token { name: 'start',      fit: /|/, }\n      stop:       $signal.new_token { name: 'stop',       fit: /|/, }\n      pause:      $signal.new_token { name: 'pause',      fit: /|/, }\n      resume:     $signal.new_token { name: 'resume',     fit: /|/, }\n      jump:       $signal.new_token { name: 'jump',       fit: /|/, }\n      earlystop:  $error.new_token  { name: 'earlystop',  fit: /|/, }\n      loop:       $error.new_token  { name: 'loop',       fit: /|/, }\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  new_level: ( cfg ) ->\n    is_system = cfg.name.startsWith '$'\n    if @levels[ cfg.name ]?\n      throw new Error \"Ωilx__18 level #{rpr level.name} elready exists\"\n    level                   = new Level { cfg..., is_system, grammar: @, }\n    @levels[ level.name ]   = level\n    if ( not is_system ) and ( not @start_level? )\n      hide @, 'start_level', level\n      @start_level_name = level.name\n    return level\n\n  #=========================================================================================================\n  token_from_fqname: ( fqname ) ->\n    ### TAINT validate ###\n    unless isa std.text, fqname\n      throw new Error \"Ωilx__19 expected a text for fqname, got a #{type_of fqname}\"\n    unless ( match = fqname.match internals.fqname_re )?\n      throw new Error \"Ωilx__20 expected an fqname consisting of level name, dot, token name, got #{rpr fqname}\"\n    { level_name, token_name, } = match.groups\n    unless ( level = @levels[ level_name ] )?\n      throw new Error \"Ωilx__21 unknown level #{rpr level_name}\"\n    unless ( token = level.tokens[ token_name ] )?\n      throw new Error \"Ωilx__22 unknown token #{rpr token_name}\"\n    return token\n\n  #=========================================================================================================\n  _new_signal: ( name, start, source, data = null ) ->\n    unless ( token = @system_tokens[ name ] )?\n      throw new Error \"Ωilx__23 should never happen: unknown signal name #{rpr name}\"\n    R       = token.match_at start, source\n    R.assign data\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  _new_error_signal: ( ref, name, start, stop, source, message ) ->\n    R       = @system_tokens[ name ].match_at start, source\n    R.assign { message, ref, }\n    R.stop  = stop\n    R.hit   = source[ start ... stop ]\n    @state.errors.push R\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  _new_jump_signal: ( start, source, target ) ->\n    return @_new_signal 'jump', start, source, { target, }\n\n\n\n\n  #                                                                   .d8888b    .d8888b   8888b.   88888b.\n  #                                                                   88K       d88P\"         \"88b  888 \"88b\n  #                                                                   \"Y8888b.  888       .d888888  888  888\n  #                                                                        X88  Y88b.     888  888  888  888\n  #                                                                    88888P'   \"Y8888P  \"Y888888  888  888\n  #\n  #\n  #=========================================================================================================\n  scan_to_list: ( P... ) -> [ ( @scan P... )..., ]\n\n  #---------------------------------------------------------------------------------------------------------\n  scan_first: ( P... ) ->\n    ### Does the entire scan to ensure that any state is what it would be with `scan()` and `scan_to_list()`\n    but returns one first user-level lexeme: ###\n    R = null\n    for lexeme from @scan P...\n      R ?= lexeme if lexeme.is_user\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  scan: ( source ) ->\n    unless @start_level?\n      throw new Error \"Ωilx__24 no levels have been defined; unable to scan\"\n    @reset_errors() if @cfg.reset_errors\n    @reset_data()   if @cfg.reset_data\n    @reset_stack()  if @cfg.reset_stack\n    @_notify_levels()\n    source += @cfg.supply_eol if source? and ( @cfg.supply_eol isnt false )\n    yield from @_scan_1_filter_signals source\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _notify_levels: ->\n    for level_name, level of @levels\n      level._on_before_scan()\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _scan_1_filter_signals: ( source ) ->\n    if @cfg.emit_signals\n      yield from @_scan_2_merge_jumps source\n    else\n      for lexeme from @_scan_2_merge_jumps source\n        yield lexeme if lexeme.is_user or lexeme.is_error\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _scan_2_merge_jumps: ( source ) ->\n    ### Consolidate all contiguous jump signals into single signal ###\n    if source is null\n      yield from @_scan_3_validate_exhaustion source\n      return null\n    #.......................................................................................................\n    buffer = []\n    for lexeme from @_scan_3_validate_exhaustion source\n      #.....................................................................................................\n      if lexeme.fqname is '$signal.jump'\n        buffer.push lexeme\n        continue\n      #.....................................................................................................\n      if buffer.length is 0\n        yield lexeme\n        continue\n      #.....................................................................................................\n      if buffer.length is 1\n        yield buffer.pop()\n        yield lexeme\n        continue\n      #.....................................................................................................\n      jump                = buffer.at  0\n      ### TAINT use API? ###\n      last_jump           = buffer.at -1\n      jump.stop           = last_jump.stop\n      jump.assign { target: last_jump.data.target, }\n      buffer.length       = 0\n      yield jump\n      yield lexeme\n    #.......................................................................................................\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _scan_3_validate_exhaustion: ( source ) ->\n    if source is null\n      yield from @_scan_4_merge source\n      return null\n    #.......................................................................................................\n    is_first    = true\n    last_idx    = source.length\n    #.......................................................................................................\n    for lexeme from @_scan_4_merge source\n      switch true\n        #...................................................................................................\n        when lexeme.fqname is '$signal.stop'\n          if lexeme.stop isnt last_idx\n            message = \"expected stop at #{last_idx}, got #{rpr lexeme.stop}\"\n            switch @cfg.earlystop_errors\n              when 'emit'\n                yield @_new_error_signal 'Ωilx__25', 'earlystop', lexeme.stop, last_idx, source, \\\n                  \"expected stop at #{last_idx}, got #{rpr lexeme.stop}\"\n              when 'throw'\n                throw new Error \"Ωilx__26 #{message}\"\n        #...................................................................................................\n        when lexeme.level.name is '$signal'\n          null\n        #...................................................................................................\n        when is_first and ( lexeme.start isnt 0 )\n          yield @_new_error_signal 'Ωilx__27', 'latestart', 0, lexeme.start, source, \\\n            \"expected start at 0, got #{rpr lexeme.start}\"\n      #.....................................................................................................\n      yield lexeme\n      is_first    = false\n    #.......................................................................................................\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _scan_4_merge: ( source ) ->\n    if source is null\n      yield from @_scan_5_insert_jumps source\n      return null\n    #.......................................................................................................\n    lexemes       = []\n    active_fqname = null\n    #.......................................................................................................\n    merge_data_as_lists = ( merged, lexemes ) ->\n      R = Object.create null\n      for lexeme in lexemes\n        for key, value of lexeme.data\n          ( R[ key ] ?= [] ).push value\n      merged.assign R\n      return null\n    #.......................................................................................................\n    flush = ->\n      return null unless active_fqname?\n      merged = ( lexemes.at 0 )._clone()\n      last_lexeme = lexemes.at -1\n      merged.hit  = ( lxm.hit for lxm in lexemes ).join ''\n      merged.stop = last_lexeme.stop\n      switch merged.token.data_merge_strategy\n        when 'assign' then merged.assign ( lxm.data for lxm in lexemes )...\n        when 'call'   then merged.token.merge.call null, { merged, lexemes, }\n        when 'list'   then merge_data_as_lists merged, lexemes\n        else throw new Error \"Ωilx__28 should never happen: encountered data_merge_strategy == #{rpr merged.token.data_merge_strategy}\"\n      yield merged\n      active_fqname = null\n      lexemes.length = 0\n      return null\n    #.......................................................................................................\n    for lexeme from @_scan_5_insert_jumps source\n      if ( not lexeme.token.merge ) or lexeme.is_signal\n        yield from flush()\n        yield lexeme\n        continue\n      if lexeme.fqname is active_fqname\n        lexemes.push lexeme\n        continue\n      yield from flush()\n      active_fqname = lexeme.fqname\n      lexemes.push lexeme\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _scan_5_insert_jumps: ( source ) ->\n    prv_level_name = @state.current_token?.level.name ? null\n    #.......................................................................................................\n    new_jump_signal = ( start, level_name ) =>\n      prv_level_name = level_name\n      return @_new_jump_signal start, ( source ? '' ), level_name\n    #.......................................................................................................\n    for lexeme from @_scan_6_insert_startstop_lnr source then switch true\n      #.....................................................................................................\n      when lexeme.fqname is '$signal.start'\n        yield lexeme\n        yield new_jump_signal 0, @start_level.name\n      #.....................................................................................................\n      when lexeme.fqname is '$signal.stop'\n        yield new_jump_signal lexeme.start, null\n        yield lexeme\n      #.....................................................................................................\n      when lexeme.is_user\n        { token, } = lexeme\n        @state.current_token = token\n        yield new_jump_signal lexeme.start,  token.level.name if token.level.name  isnt prv_level_name\n        yield new_jump_signal lexeme.start, lexeme.level.name if lexeme.level.name isnt prv_level_name\n        yield lexeme if token.emit\n      #.....................................................................................................\n      else yield lexeme\n    #.......................................................................................................\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _scan_6_insert_startstop_lnr: ( source ) ->\n    if source is null\n      yield @_new_signal 'stop', 0, ''\n      return null\n    #.......................................................................................................\n    @state.current_stop = 0\n    if @cfg.linking and @state.current_token?\n      yield @_new_signal 'resume', 0, source\n    else\n      yield @_new_signal 'start', 0, source\n    for lexeme from @_scan_7_apply_casts source\n      @state.current_stop = lexeme.stop if lexeme.is_user\n      yield lexeme\n    if @cfg.linking\n      yield @_new_signal 'pause', @state.current_stop, source\n    else\n      yield @_new_signal 'stop', @state.current_stop, source\n    @state.lnr++ unless @cfg.reset_lnr\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _scan_7_apply_casts: ( source ) ->\n    for lexeme from @_scan_8_match_tokens source\n      unless lexeme.is_user\n        yield lexeme\n        continue\n      #.....................................................................................................\n      cast_owner = switch true\n        when lexeme.token.cast? then lexeme.token\n        when lexeme.level.cast? then lexeme.level\n        when             @cast? then @\n        else null\n      #.....................................................................................................\n      unless cast_owner?\n        yield lexeme\n        continue\n      #.....................................................................................................\n      switch cast_owner.cast_method\n        when 'call'\n          cast_owner.cast.call @, lexeme._as_proxy()\n          yield lexeme\n        when 'walk'\n          yield from cast_owner.cast.call @, lexeme._as_proxy()\n        else throw new Error \"Ωilx__29 should never happen: got unknown cast_method #{rpr cast_owner.cast_method}\"\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _scan_8_match_tokens: ( source ) ->\n    start           = 0\n    lexeme          = null\n    old_level_name  = null\n    stack           = @state.stack\n    goto_token      = null\n    if @cfg.linking and ( goto_token = @state.current_token )?\n      ### TAINT just push start_level and token.level to stack? ###\n      unless goto_token.level is ( last_level = stack.peek null )\n        throw new Error \"Ωilx__30 expected level of #{goto_token.fqname} on stack, found #{last_level?.name ? 'nothing'}\"\n    else\n      stack.push @start_level\n    #.......................................................................................................\n    loop\n      level         = stack.peek()\n      new_level     = level\n      lexeme        = level.match_at start, source # , { goto_token, }\n      break unless lexeme? # terminate if current level has no matching tokens\n      start         = lexeme.stop\n      #.....................................................................................................\n      if ( jump = lexeme.jump )?\n        switch jump.action\n          when 'fore' then  stack.push ( new_level = @_get_level jump.target )\n          when 'back' then  new_level = stack.popnpeek()\n          else throw new Error \"Ωilx__31 should never happen: unknown jump action #{rpr lexeme.jump.action}\"\n        if jump.carry\n          lexeme.set_level new_level\n      #.....................................................................................................\n      yield lexeme\n      ### TAINT this should really check for lexeme.terminate ###\n      break if lexeme.is_error\n    #.......................................................................................................\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _get_level: ( level_name ) ->\n    return R if ( R = @levels[ level_name ] )?\n    throw new Error \"Ωilx__32 unknown level #{rpr level_name}\"\n\n\n#===========================================================================================================\nmodule.exports = {\n  Token\n  Lexeme\n  Level\n  Grammar\n  internals\n  rx\n  new_regex_tag }\n\n"
  ]
}