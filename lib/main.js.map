{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/main.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n'use strict'\n\n#===========================================================================================================\n{ hide\n  debug\n  info\n  rpr                   } = require './helpers'\n#-----------------------------------------------------------------------------------------------------------\n{ partial, regex, }       = require 'regex'\nrx                        = regex 'y'\n#-----------------------------------------------------------------------------------------------------------\n### NOTE: may add punctuation later, therefore better to be restrictive ###\n### thx to https://github.com/sindresorhus/identifier-regex ###\n_jsid_re                  = regex\"\"\" ^ [ $ _ \\p{ID_Start} ] [ $ _ \\u200C \\u200D \\p{ID_Continue} ]* $ \"\"\"\n_jump_spec_back           = '..'\n_jump_spec_re             = regex\" (?<back> ^ #{_jump_spec_back} $ ) | (?<fore> #{_jsid_re} )\"\n\n\n#===========================================================================================================\nclass Token\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    @name = cfg.name\n    hide @, 'level',        cfg.level\n    hide @, 'grammar',      cfg.level.grammar\n    hide @, 'matcher',      cfg.matcher\n    hide @, 'jump',         @constructor._parse_jump cfg.jump ? null\n    hide @, 'jump_spec',    cfg.jump                          ? null\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  match_at: ( start, text ) ->\n    @matcher.lastIndex = start\n    return null unless ( match = text.match @matcher )?\n    return new Lexeme @, match\n\n  #---------------------------------------------------------------------------------------------------------\n  @_parse_jump: ( jump_spec ) ->\n    return null unless jump_spec?\n    ### TAINT use cleartype ###\n    unless ( match = jump_spec.match _jump_spec_re )?\n      throw new Error \"Ω___1 expected a well-formed jump literal, got #{rpr jump_spec}\"\n    return { action: 'back', target: null,              } if match.groups.back\n    return { action: 'fore', target: match.groups.fore, }\n\n\n#===========================================================================================================\nclass Lexeme\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( token, match ) ->\n    # debug 'Ω___2', token\n    # debug 'Ω___3', token.jump, token.grammar.levels[ token.jump.level ] if token.jump?\n    @name       = token.name\n    @fqname     = \"#{token.level.name}.#{token.name}\"\n    @level      = token.level\n    @hit        = match[ 0 ]\n    @start      = match.index\n    @stop       = @start + @hit.length\n    @groups     = match.groups ? null\n    @jump       = token.jump\n    @jump_spec  = token.jump_spec\n    name        = token.grammar.cfg.counter_name\n    count       = token.grammar.state.count\n    @[ name ]   = count\n    return undefined\n\n\n#===========================================================================================================\nclass Level\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    cfg    ?= {}\n    @name   = cfg.name ? 'gnd'\n    hide @, 'grammar',  cfg.grammar\n    hide @, 'tokens',   [ ( cfg.tokens ? [] )..., ]\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  [Symbol.iterator]: -> yield t for t in @tokens\n\n  #---------------------------------------------------------------------------------------------------------\n  new_token: ( cfg ) ->\n    if cfg.level? and cfg.level isnt @\n      throw new Error \"Ω___4 inconsistent level\"\n    @tokens.push token = new Token { cfg..., level: @, }\n    return token\n\n\n#===========================================================================================================\nclass Stack\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( P... ) ->\n    @data = Array.from P...\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  is_empty: -> @data.length is 0\n\n  #---------------------------------------------------------------------------------------------------------\n  peek: ->\n    if @is_empty()\n      throw new Error \"stack is empty\"\n    return @data.at -1\n\n  #---------------------------------------------------------------------------------------------------------\n  pop: ->\n    if @is_empty()\n      throw new Error \"stack is empty\"\n    return @data.pop()\n\n  #---------------------------------------------------------------------------------------------------------\n  push: ( P... ) -> @data.push P...\n\n\n#===========================================================================================================\nclass Grammar\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    cfg_template      =\n      name:               'g'\n      counter_name:       'line_nr'\n      counter_value:      1\n      counter_step:       1\n    @cfg             ?= { cfg_template..., cfg..., }\n    @state            =\n      count:              @cfg.counter_value\n    @name             = cfg.name\n    @start_level_name = null\n    hide @, 'start_level', null\n    hide @, 'levels',   {}\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  new_level: ( cfg ) ->\n    if @levels[ cfg.name ]?\n      throw new Error \"Ω___5 level #{rpr level.name} elready exists\"\n    level                   = new Level { cfg..., grammar: @, }\n    @levels[ level.name ]   = level\n    unless @start_level?\n      hide @, 'start_level', level\n      @start_level_name = level.name\n    return level\n\n  #---------------------------------------------------------------------------------------------------------\n  get_tokens: ( P... ) -> [ ( @walk_tokens P... )..., ]\n\n  #---------------------------------------------------------------------------------------------------------\n  walk_tokens: ( source ) ->\n    { f } = require '../../effstring'\n    start = 0\n    stack = new Stack [ @start_level, ]\n    #.......................................................................................................\n    loop\n      lexeme  = null\n      level   = stack.peek()\n      for token from level\n        break if ( lexeme = token.match_at start, source )?\n      #.....................................................................................................\n      ### Terminate if none of the tokens of the current level has matched at the current position: ###\n      break unless lexeme?\n      #.....................................................................................................\n      yield lexeme\n      @state.count += @cfg.counter_step\n      start         = lexeme.stop\n      #.....................................................................................................\n      continue unless ( jump = lexeme.jump )?\n      switch jump.action\n        #...................................................................................................\n        when 'fore'\n          ### TAINT encapsulate ###\n          unless ( new_level = @levels[ jump.target ] )?\n            throw new Error \"unknown level #{rpr jump.target}\"\n          stack.push new_level\n          continue\n        #...................................................................................................\n        when 'back'\n          stack.pop()\n          continue\n      #.....................................................................................................\n      throw new Error \"unknown jump action #{rpr lexeme.jump.action}\"\n    return null\n\n\n  #===========================================================================================================\n  ###\n  `Token` defines `matcher`, can jump into a level or back\n  `Level` has one or more `Token`s\n  `Grammar` has one or more `Level`s\n  `Lexeme` produced by a `Token` instance when matcher matches source\n\n  ###\n\n\nmodule.exports = {\n  Token\n  Lexeme\n  Level\n  Grammar\n  rx\n  _jsid_re\n  _jump_spec_re }\n\n"
  ]
}