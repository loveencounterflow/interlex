{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/main.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n'use strict'\n\n#===========================================================================================================\n{ hide\n  debug\n  info\n  rpr                   } = require './helpers'\n#-----------------------------------------------------------------------------------------------------------\n{ partial, regex, }       = require 'regex'\nrx                        = regex 'y'\n#-----------------------------------------------------------------------------------------------------------\n### NOTE: may add punctuation later, therefore better to be restrictive ###\n### thx to https://github.com/sindresorhus/identifier-regex ###\n_jsid_re                  = regex\"\"\" ^ [ $ _ \\p{ID_Start} ] [ $ _ \\u200C \\u200D \\p{ID_Continue} ]* $ \"\"\"\n_jump_spec_back           = '..'\n_jump_spec_re             = regex\" (?<back> ^ #{_jump_spec_back} $ ) | (?<fore> #{_jsid_re} )\"\n\n\n#===========================================================================================================\nclass Token\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    debug 'Ω___1', \"new Token\", cfg.name, cfg.level, cfg.level.grammar\n    @name = cfg.name\n    hide @, 'level',        cfg.level\n    hide @, 'grammar',      cfg.level.grammar\n    hide @, 'matcher',      cfg.matcher\n    hide @, 'jump',         @constructor._parse_jump cfg.jump ? null\n    hide @, 'jump_spec',    cfg.jump                          ? null\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  match_at: ( start, text ) ->\n    @matcher.lastIndex = start\n    return null unless ( match = text.match @matcher )?\n    return new Lexeme @, match\n\n  #---------------------------------------------------------------------------------------------------------\n  @_parse_jump: ( jump_spec ) ->\n    return null unless jump_spec?\n    ### TAINT use cleartype ###\n    unless ( match = jump_spec.match _jump_spec_re )?\n      throw new Error \"Ω___2 expected a well-formed jump literal, got #{rpr jump_spec}\"\n    return { action: 'back', target: null,              } if match.groups.back\n    return { action: 'fore', target: match.groups.fore, }\n\n\n#===========================================================================================================\nclass Lexeme\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( token, match ) ->\n    # debug 'Ω___3', token\n    # debug 'Ω___4', token.jump, token.grammar.levels[ token.jump.level ] if token.jump?\n    @name         = token.name\n    @fqname       = \"#{token.level.name}.#{token.name}\"\n    @level        = token.level\n    @hit          = match[ 0 ]\n    @start        = match.index\n    @stop         = @start + @hit.length\n    @groups       = match.groups ? null\n    @jump         = token.jump\n    @jump_spec    = token.jump_spec\n    return undefined\n\n\n#===========================================================================================================\nclass Level\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    cfg    ?= {}\n    @name   = cfg.name ? 'gnd'\n    hide @, 'grammar',  cfg.grammar\n    hide @, 'tokens',   [ ( cfg.tokens ? [] )..., ]\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  [Symbol.iterator]: -> yield t for t in @tokens\n\n  #---------------------------------------------------------------------------------------------------------\n  new_token: ( cfg ) ->\n    if cfg.level? and cfg.level isnt @\n      throw new Error \"Ω___5 inconsistent level\"\n    @tokens.push token = new Token { cfg..., level: @, }\n    return token\n\n#===========================================================================================================\nclass Grammar\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    cfg              ?= {}\n    @name             = cfg.name ? 'g'\n    @start_name       = null\n    hide @, 'start',    null\n    hide @, 'levels',   { ( cfg.levels ? {} )..., }\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  new_level: ( cfg ) ->\n    if @levels[ cfg.name ]?\n      throw new Error \"Ω___6 level #{rpr level.name} elready exists\"\n    level                   = new Level { cfg..., grammar: @, }\n    @levels[ level.name ]   = level\n    unless @start?\n      hide @, 'start', level\n      @start_name = level.name\n    return level\n\n  #---------------------------------------------------------------------------------------------------------\n  tokenize: ( source ) ->\n    { f } = require '../../effstring'\n    start   = 0\n    # level   = @start\n    stack   = [ @start, ]\n    #.......................................................................................................\n    loop\n      lexeme  = null\n      ### TAINT encapsulate in stack class ###\n      level   = stack.at -1\n      for token from level\n        break if ( lexeme = token.match_at start, source )?\n      break unless lexeme?\n      yield lexeme\n      start = lexeme.stop\n      #.....................................................................................................\n      continue unless ( jump = lexeme.jump )?\n      switch jump.action\n        #...................................................................................................\n        when 'fore'\n          ### TAINT encapsulate ###\n          unless ( new_level = @levels[ jump.target ] )?\n            throw new Error \"unknown level #{rpr jump.target}\"\n          stack.push new_level\n          continue\n        #...................................................................................................\n        when 'back'\n          ### TAINT encapsulate in stack class ###\n          unless stack.length > 0\n            throw new Error \"stack is empty\"\n          stack.pop()\n          continue\n      #.....................................................................................................\n      throw new Error \"unknown jump action #{rpr lexeme.jump.action}\"\n    return null\n\n\n  #===========================================================================================================\n  ###\n  `Token` defines `matcher`, can jump into a level or back\n  `Level` has one or more `Token`s\n  `Grammar` has one or more `Level`s\n  `Lexeme` produced by a `Token` instance when matcher matches source\n\n  ###\n\n\nmodule.exports = {\n  Token\n  Lexeme\n  Level\n  Grammar\n  rx\n  _jsid_re\n  _jump_spec_re }\n\n"
  ]
}